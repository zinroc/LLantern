'use strict';

var fs = require('fs');
var path = require('path');

var _ = require('lodash');

var _require = require('../lib/tree'),
    Folder = _require.Folder;

var _require2 = require('../lib/parseUtils'),
    getModuleSizesFromBundle = _require2.getModuleSizesFromBundle;

module.exports = {
  getChartData: getChartData,
  readStatsFromFile: readStatsFromFile
};

function getChartData(bundleStats, bundleDir) {
  // Picking only `*.js` assets from bundle that has non-empty `chunks` array
  bundleStats.assets = _.filter(bundleStats.assets, function (asset) {
    return _.endsWith(asset.name, '.js') && !_.isEmpty(asset.chunks);
  });

  // Real module sizes got by parsing assets
  var parsedModuleSizes = null;

  if (bundleDir) {
    // Checking if all assets are exist
    var bundleScriptsFound = _.every(bundleStats.assets, function (statAsset) {
      var assetFile = path.resolve(bundleDir, statAsset.name);
      var assetExists = fs.existsSync(assetFile);

      if (!assetExists) {
        console.log('\nUnable to find bundle asset "' + assetFile + '".\n' + 'Analyzer will use module sizes from stats file.\n');
      }

      return assetExists;
    });

    if (bundleScriptsFound) {
      // Parsing assets and getting real module sizes
      parsedModuleSizes = _.transform(bundleStats.assets, function (result, statAsset) {
        _.assign(result, getModuleSizesFromBundle(path.resolve(bundleDir, statAsset.name)));
      }, {});
    }
  }

  var assets = _.transform(bundleStats.assets, function (result, statAsset) {
    var bundleFilename = statAsset.name;
    var asset = result[bundleFilename] = _.pick(statAsset, 'size');

    // Picking modules from current bundle script
    asset.modules = _(bundleStats.modules).filter(function (statModule) {
      return assetHasModule(statAsset, statModule);
    }).each(function (statModule) {
      if (parsedModuleSizes) {
        statModule.parsedSize = parsedModuleSizes[statModule.id];
      }
    });

    asset.tree = createModulesTree(asset.modules);
  }, {});

  return _.transform(assets, function (result, asset, filename) {
    var statSize = asset.tree.size;
    var parsedSize = parsedModuleSizes ? asset.tree.parsedSize : undefined;

    result.push({
      label: filename,
      weight: parsedSize === undefined ? statSize : parsedSize,
      statSize: statSize,
      parsedSize: parsedSize,
      groups: _.invokeMap(asset.tree.children, 'toChartData')
    });
  }, []);
}

function readStatsFromFile(filename) {
  return JSON.parse(fs.readFileSync(filename, 'utf8'));
}

function assetHasModule(statAsset, statModule) {
  return _.some(statModule.chunks, function (moduleChunk) {
    return _.includes(statAsset.chunks, moduleChunk);
  });
}

function createModulesTree(modules) {
  var root = new Folder('.');

  _.each(modules, function (module) {
    var path = getModulePath(module.name);
    root.addFileByPath(path, module);
  });

  return root;
}

function getModulePath(path) {
  return _(path).split('/').slice(1).map(function (part) {
    return part === '~' ? 'node_modules' : part;
  }).value();
}